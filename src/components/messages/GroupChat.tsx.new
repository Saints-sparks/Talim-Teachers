import { useState, useEffect, useRef } from "react";
import { useAuth } from "@/app/hooks/useAuth";
import { useWebSocketContext } from "@/app/contexts/WebSocketContext";
import ChatHeader from "./ChatHeader";
import MessageInput from "./MessageInput";
import GroupMessageBubble from "./GroupMessageBubble";
import ReplyPreview from "./ReplyPreview";
import { Loader2 } from "lucide-react";
import { getChatMessages } from "@/app/services/chat.service";
import { ChatMessage as WebSocketChatMessage } from "@/app/hooks/useWebSocket";
import { useAppContext } from "@/app/context/AppContext";

// Define the message structure for our UI
interface Message {
  _id?: string;
  id?: string;
  sender: string;
  senderId?: string;
  senderName?: string;
  text?: string;
  content?: string;
  time?: string;
  createdAt?: string;
  type: string;
  senderType: string;
  avatar?: string;
  color?: string;
  roomId?: string;
  replyTo?: string;
  videoThumbnail?: string;
  duration?: string;
}

interface GroupChatProps {
  replyingMessage: { sender: string; text: string } | null;
  setReplyingMessage: (msg: any) => void;
  openSubMenu: { index: number; type: string } | null;
  toggleSubMenu: (index: number, type: string) => void;
  room?: any; // The selected chat room
}

export default function GroupChat({
  replyingMessage,
  setReplyingMessage,
  openSubMenu,
  toggleSubMenu,
  room,
}: GroupChatProps) {
  const [messages, setMessages] = useState<Message[]>([]);
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);
  const [messageInput, setMessageInput] = useState<string>('');
  const [isSending, setIsSending] = useState<boolean>(false);
  
  // For cursor-based pagination
  const [hasMore, setHasMore] = useState<boolean>(true);
  const [oldestMessageId, setOldestMessageId] = useState<string | null>(null);
  const [isLoadingMore, setIsLoadingMore] = useState<boolean>(false);
  
  // Refs for scroll management
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const messagesContainerRef = useRef<HTMLDivElement>(null);
  
  const { getAccessToken, user } = useAuth();
  const { classes, courses } = useAppContext();
  const webSocket = useWebSocketContext();
  
  // Cleanup function reference
  const cleanupRef = useRef<(() => void) | null>(null);

  // Helper to get color based on sender
  const getColorForUser = (senderId: string): string => {
    // Create a consistent color based on user ID
    const colorOptions = [
      "text-[#F39C12]",
      "text-[#3498DB]",
      "text-[#9B59B6]",
      "text-[#2ECC71]",
      "text-[#1ABC9C]",
      "text-[#E74C3C]",
      "text-[#34495E]"
    ];
    
    // Use a hash function to get a consistent index
    const hash = senderId.split('').reduce((acc, char) => {
      return acc + char.charCodeAt(0);
    }, 0);
    
    return colorOptions[hash % colorOptions.length];
  };

  // Helper to get user role
  const getUserRole = (senderId: string): "teacher" | "student" | "other" => {
    // Here you would check if the user is a teacher based on your data model
    // For this example, let's assume they're a teacher if they have a specific role
    if (senderId === user?.userId) return "teacher";
    
    // Check if they're in a teacher list or have teacher role
    // This is placeholder logic - adjust based on your data structure
    return "student";
  };
  
  // Fetch initial messages and join the chat room when a room is selected
  useEffect(() => {
    if (!room?._id && !room?.id) return;
    
    const roomId = room._id || room.id;
    let isMounted = true;
    
    const fetchMessages = async () => {
      setIsLoading(true);
      setError(null);
      
      try {
        const token = getAccessToken();
        if (!token) throw new Error("Authentication required");
        
        // Fetch messages using REST API
        const data = await getChatMessages(roomId, token);
        console.log('📥 Fetched messages:', data);
        
        if (isMounted && data && Array.isArray(data.messages)) {
          const formattedMessages = data.messages.map((msg: any) => ({
            _id: msg._id || msg.id,
            sender: msg.senderName || 'Unknown',
            senderId: msg.senderId,
            text: msg.content,
            time: new Date(msg.createdAt).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
            type: msg.type || 'text',
            senderType: msg.senderId === user?.userId ? "self" : getUserRole(msg.senderId),
            color: getColorForUser(msg.senderId),
            avatar: '/image/teachers/mathematics.png', // Default avatar, should be replaced with actual user avatar
          }));
          
          setMessages(formattedMessages);
          
          // Set oldest message ID for pagination
          if (formattedMessages.length > 0) {
            setOldestMessageId(formattedMessages[0]._id);
          }
          
          // Check if there are more messages to load
          setHasMore(data.hasMore || false);
        }
      } catch (err: any) {
        console.error('Error fetching messages:', err);
        if (isMounted) {
          setError(`Failed to load messages: ${err.message}`);
        }
      } finally {
        if (isMounted) {
          setIsLoading(false);
        }
      }
    };
    
    // Join the chat room via WebSocket
    const joinChatRoom = () => {
      if (!webSocket.isConnected) {
        console.log('⚠️ WebSocket not connected. Will join room when connected.');
        return null;
      }
      
      console.log(`🚪 Joining chat room: ${roomId}`);
      
      // Join chat room using the WebSocketContextType method
      webSocket.joinChatRoom(roomId);
      
      // Set up chat message listener
      return webSocket.onChatMessage(handleNewMessage);
    };
    
    fetchMessages();
    const unsubscribe = joinChatRoom();
    
    if (unsubscribe) {
      cleanupRef.current = unsubscribe;
    }
    
    // Clean up event listeners when component unmounts or room changes
    return () => {
      isMounted = false;
      if (webSocket.isConnected && roomId) {
        console.log(`🚪 Leaving chat room: ${roomId}`);
        webSocket.leaveChatRoom(roomId);
        
        if (cleanupRef.current) {
          cleanupRef.current();
          cleanupRef.current = null;
        }
      }
    };
  }, [room, webSocket.isConnected]);
  
  // Scroll to bottom when messages change
  useEffect(() => {
    if (messagesEndRef.current) {
      messagesEndRef.current.scrollIntoView({ behavior: 'smooth' });
    }
  }, [messages]);
  
  // Handle WebSocket connection changes
  useEffect(() => {
    if (webSocket.isConnected && room) {
      const roomId = room._id || room.id;
      console.log(`🔄 WebSocket reconnected, rejoining room: ${roomId}`);
      
      webSocket.joinChatRoom(roomId);
      
      // Set up chat message listener and store cleanup function
      const unsubscribe = webSocket.onChatMessage(handleNewMessage);
      cleanupRef.current = unsubscribe;
      
      // Return cleanup function
      return unsubscribe;
    }
  }, [webSocket.isConnected]);
  
  // Handle new incoming messages via WebSocket
  const handleNewMessage = (newMessage: WebSocketChatMessage) => {
    console.log('📨 New message received:', newMessage);
    
    // Only process messages for the current room
    if (newMessage.roomId !== (room?._id || room?.id)) {
      return;
    }
    
    // Format the incoming message
    const formattedMessage: Message = {
      _id: newMessage._id,
      sender: newMessage.senderName || 'Unknown',
      senderId: newMessage.senderId,
      text: newMessage.content,
      time: new Date(newMessage.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
      type: newMessage.type || 'text',
      senderType: newMessage.senderId === user?.userId ? "self" : getUserRole(newMessage.senderId),
      color: getColorForUser(newMessage.senderId),
      avatar: '/image/teachers/mathematics.png', // Default avatar, should be replaced with actual user avatar
    };
    
    setMessages(prevMessages => [...prevMessages, formattedMessage]);
  };
  
  // Handle sending a new message
  const handleSendMessage = () => {
    if (!messageInput.trim() || !room || isSending) return;
    
    const roomId = room._id || room.id;
    setIsSending(true);
    
    try {
      // Create message payload
      const messagePayload = {
        content: messageInput.trim(),
        roomId,
        senderName: user?.fullName || user?.email || 'Unknown User',
        type: 'text' as const
      };
      
      console.log('📤 Sending message:', messagePayload);
      
      // Send via WebSocket
      webSocket.sendChatMessage(messagePayload);
      
      // Clear input field
      setMessageInput('');
    } catch (err: any) {
      console.error('Error sending message:', err);
      // Display error toast/notification
    } finally {
      setIsSending(false);
    }
  };
  
  // Load older messages with pagination
  const loadMoreMessages = async () => {
    if (!room || !oldestMessageId || !hasMore || isLoadingMore) return;
    
    // We'll implement this using the REST API for now since the WebSocket method 
    // would need more complex state management for callbacks
    setIsLoadingMore(true);
    
    try {
      const token = getAccessToken();
      if (!token) throw new Error("Authentication required");
      
      const roomId = room._id || room.id;
      
      // Store scroll position
      const scrollContainer = messagesContainerRef.current;
      const scrollHeight = scrollContainer?.scrollHeight;
      
      // API call with cursor parameter (implementation may vary)
      const response = await fetch(
        `${process.env.NEXT_PUBLIC_API_URL}/chat/rooms/${roomId}/messages?cursor=${oldestMessageId}&limit=20&direction=before`,
        {
          headers: {
            Authorization: `Bearer ${token}`,
          },
        }
      );
      
      const data = await response.json();
      
      if (data && Array.isArray(data.messages) && data.messages.length > 0) {
        const formattedMessages = data.messages.map((msg: any) => ({
          _id: msg._id || msg.id,
          sender: msg.senderName || 'Unknown',
          senderId: msg.senderId,
          text: msg.content,
          time: new Date(msg.createdAt).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
          type: msg.type || 'text',
          senderType: msg.senderId === user?.userId ? "self" : getUserRole(msg.senderId),
          color: getColorForUser(msg.senderId),
          avatar: '/image/teachers/mathematics.png', // Default avatar
        }));
        
        // Update oldest message ID for next pagination
        if (formattedMessages.length > 0) {
          setOldestMessageId(formattedMessages[0]._id);
        }
        
        // Prepend older messages
        setMessages(prevMessages => [...formattedMessages, ...prevMessages]);
        
        // Check if there are more messages to load
        setHasMore(data.hasMore || false);
        
        // Restore scroll position
        if (scrollContainer && scrollHeight) {
          setTimeout(() => {
            scrollContainer.scrollTop = scrollContainer.scrollHeight - scrollHeight;
          }, 0);
        }
      } else {
        setHasMore(false);
      }
    } catch (err: any) {
      console.error('Error loading more messages:', err);
    } finally {
      setIsLoadingMore(false);
    }
  };
  
  // Handle scroll to load more messages
  const handleScroll = () => {
    const scrollContainer = messagesContainerRef.current;
    if (scrollContainer && scrollContainer.scrollTop === 0 && hasMore && !isLoadingMore) {
      loadMoreMessages();
    }
  };
  
  // Format the group name and participants for display
  const getRoomName = () => {
    if (room?.name) return room.name;
    
    if (room?.type === "class_group" && room?.classId && classes) {
      const classInfo = classes.find((c: any) => c._id === room.classId || c.id === room.classId);
      return classInfo?.name || "Class Group";
    }
    
    if (room?.type === "course_group" && room?.courseId && courses) {
      const courseInfo = courses.find((c: any) => c._id === room.courseId || c.id === room.courseId);
      return courseInfo?.title || courseInfo?.name || "Course Group";
    }
    
    return "Group Chat";
  };
  
  const getParticipantsText = () => {
    if (!room?.participants || !Array.isArray(room.participants)) {
      return "";
    }
    
    return room.participants
      .filter((p: any) => p.userId !== user?.userId)
      .map((p: any) => p.name)
      .join(", ");
  };
  
  const roomName = getRoomName();
  const participantsText = getParticipantsText();
  
  return (
    <div className="lg:w-3/5 xl:w-2/3 flex flex-col relative">
      <div className="flex items-center rounded-tr-lg p-4 border-b bg-white">
        <ChatHeader
          avatar={room?.avatar || "/icons/chat.svg"}
          name={roomName}
          subtext={participantsText}
        />
      </div>
      
      <div 
        className="flex-1 overflow-y-auto p-4 space-y-2"
        ref={messagesContainerRef}
        onScroll={handleScroll}
      >
        {/* Loading indicator for more messages */}
        {isLoadingMore && (
          <div className="flex justify-center py-2">
            <Loader2 className="h-5 w-5 animate-spin text-blue-600" />
          </div>
        )}
        
        {/* Date divider */}
        <div className="text-center px-4 py-2 bg-white rounded-md w-fit mx-auto text-xs text-[#030E18] my-4">
          Today
        </div>
        
        {/* Main loading state */}
        {isLoading ? (
          <div className="flex flex-col items-center justify-center h-48">
            <Loader2 className="h-8 w-8 animate-spin text-blue-600 mb-2" />
            <p className="text-sm text-gray-500">Loading messages...</p>
          </div>
        ) : error ? (
          <div className="flex flex-col items-center justify-center h-48">
            <p className="text-sm text-red-500 mb-2">{error}</p>
            <button 
              className="px-4 py-2 bg-blue-600 text-white rounded-md text-sm"
              onClick={() => window.location.reload()}
            >
              Retry
            </button>
          </div>
        ) : messages.length === 0 ? (
          <div className="flex flex-col items-center justify-center h-48">
            <p className="text-sm text-gray-500 mb-2">No messages yet</p>
            <p className="text-xs text-gray-400">Send a message to start the conversation</p>
          </div>
        ) : (
          messages.map((msg, index) => (
            <GroupMessageBubble
              key={msg._id || index}
              msg={{
                sender: msg.sender,
                text: msg.text || msg.content || '',
                time: msg.time || '',
                type: msg.type,
                senderType: msg.senderType,
                avatar: msg.avatar || '/icons/user-placeholder.svg',
                color: msg.color || 'text-[#F39C12]',
              }}
              index={index}
              openSubMenu={openSubMenu}
              toggleSubMenu={toggleSubMenu}
              setReplyingMessage={setReplyingMessage}
            />
          ))
        )}
        
        {/* Invisible element to scroll to */}
        <div ref={messagesEndRef} />
      </div>

      {replyingMessage && (
        <ReplyPreview
          replyingMessage={replyingMessage}
          onCancel={() => setReplyingMessage(null)}
        />
      )}

      <MessageInput 
        value={messageInput}
        onChange={(e: React.ChangeEvent<HTMLInputElement>) => setMessageInput(e.target.value)}
        onSend={handleSendMessage}
        disabled={!room || isSending || !webSocket.isConnected}
        placeholder={
          !webSocket.isConnected 
            ? "Connecting..." 
            : !room 
              ? "Select a chat to start messaging" 
              : "Type a message..."
        }
      />
    </div>
  );
}
