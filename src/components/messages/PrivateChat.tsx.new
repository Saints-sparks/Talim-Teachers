import { useState, useEffect, useRef } from "react";
import { useAuth } from "@/app/hooks/useAuth";
import { useWebSocketContext } from "@/app/contexts/WebSocketContext";
import ChatHeader from "./ChatHeader";
import MessageInput from "./MessageInput";
import MessageBubble from "./PrivateMessageBubble";
import ReplyPreview from "./ReplyPreview";
import { Loader2 } from "lucide-react";
import { getChatMessages } from "@/app/services/chat.service";
import { ChatMessage as WebSocketChatMessage } from "@/app/hooks/useWebSocket";

// Define the message structure for our UI
interface Message {
  _id?: string;
  id?: string;
  sender: string;
  senderId?: string;
  senderName?: string;
  text?: string;
  content?: string;
  time?: string;
  createdAt?: string;
  type: string;
  senderType: string;
  avatar?: string;
  color?: string;
  roomId?: string;
  replyTo?: string;
}

interface PrivateChatProps {
  replyingMessage: { sender: string; text: string } | null;
  setReplyingMessage: (msg: any) => void;
  openSubMenu: { index: number; type: string } | null;
  toggleSubMenu: (index: number, type: string) => void;
  room?: any; // The selected chat room
}

export default function PrivateChat({
  replyingMessage,
  setReplyingMessage,
  openSubMenu,
  toggleSubMenu,
  room,
}: PrivateChatProps) {
  const [messages, setMessages] = useState<Message[]>([]);
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);
  const [messageInput, setMessageInput] = useState<string>('');
  const [isSending, setIsSending] = useState<boolean>(false);
  
  // For cursor-based pagination
  const [hasMore, setHasMore] = useState<boolean>(true);
  const [oldestMessageId, setOldestMessageId] = useState<string | null>(null);
  const [isLoadingMore, setIsLoadingMore] = useState<boolean>(false);
  
  // Refs for scroll management
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const messagesContainerRef = useRef<HTMLDivElement>(null);
  
  const { getAccessToken, user } = useAuth();
  const webSocket = useWebSocketContext();
  
  // Cleanup function reference
  const cleanupRef = useRef<(() => void) | null>(null);
  
  // Fetch initial messages and join the chat room when a room is selected
  useEffect(() => {
    if (!room?._id && !room?.id) return;
    
    const roomId = room._id || room.id;
    let isMounted = true;
    
    const fetchMessages = async () => {
      setIsLoading(true);
      setError(null);
      
      try {
        const token = getAccessToken();
        if (!token) throw new Error("Authentication required");
        
        // Fetch messages using REST API
        const data = await getChatMessages(roomId, token);
        console.log('ðŸ“¥ Fetched messages:', data);
        
        if (isMounted && data && Array.isArray(data.messages)) {
          const formattedMessages = data.messages.map((msg: any) => ({
            _id: msg._id || msg.id,
            sender: msg.senderName || 'Unknown',
            senderId: msg.senderId,
            text: msg.content,
            time: new Date(msg.createdAt).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
            type: msg.type || 'text',
            senderType: msg.senderId === user?.userId ? 'me' : 'other',
            color: msg.senderId === user?.userId ? 'green' : 'blue',
          }));
          
          setMessages(formattedMessages);
          
          // Set oldest message ID for pagination
          if (formattedMessages.length > 0) {
            setOldestMessageId(formattedMessages[0]._id);
          }
          
          // Check if there are more messages to load
          setHasMore(data.hasMore || false);
        }
      } catch (err: any) {
        console.error('Error fetching messages:', err);
        if (isMounted) {
          setError(`Failed to load messages: ${err.message}`);
        }
      } finally {
        if (isMounted) {
          setIsLoading(false);
        }
      }
    };
    
    // Join the chat room via WebSocket
    const joinChatRoom = () => {
      if (!webSocket.isConnected) {
        console.log('âš ï¸ WebSocket not connected. Will join room when connected.');
        return null;
      }
      
      console.log(`ðŸšª Joining chat room: ${roomId}`);
      
      // Join chat room using the WebSocketContextType method
      webSocket.joinChatRoom(roomId);
      
      // Set up chat message listener
      return webSocket.onChatMessage(handleNewMessage);
    };
    
    fetchMessages();
    const unsubscribe = joinChatRoom();
    
    if (unsubscribe) {
      cleanupRef.current = unsubscribe;
    }
    
    // Clean up event listeners when component unmounts or room changes
    return () => {
      isMounted = false;
      if (webSocket.isConnected && roomId) {
        console.log(`ðŸšª Leaving chat room: ${roomId}`);
        webSocket.leaveChatRoom(roomId);
        
        if (cleanupRef.current) {
          cleanupRef.current();
          cleanupRef.current = null;
        }
      }
    };
  }, [room, webSocket.isConnected]);
  
  // Scroll to bottom when messages change
  useEffect(() => {
    if (messagesEndRef.current) {
      messagesEndRef.current.scrollIntoView({ behavior: 'smooth' });
    }
  }, [messages]);
  
  // Handle WebSocket connection changes
  useEffect(() => {
    if (webSocket.isConnected && room) {
      const roomId = room._id || room.id;
      console.log(`ðŸ”„ WebSocket reconnected, rejoining room: ${roomId}`);
      
      webSocket.joinChatRoom(roomId);
      
      // Set up chat message listener and store cleanup function
      const unsubscribe = webSocket.onChatMessage(handleNewMessage);
      cleanupRef.current = unsubscribe;
      
      // Return cleanup function
      return unsubscribe;
    }
  }, [webSocket.isConnected]);
  
  // Handle new incoming messages via WebSocket
  const handleNewMessage = (newMessage: WebSocketChatMessage) => {
    console.log('ðŸ“¨ New message received:', newMessage);
    
    // Format the incoming message
    const formattedMessage: Message = {
      _id: newMessage._id,
      sender: newMessage.senderName || 'Unknown',
      senderId: newMessage.senderId,
      text: newMessage.content,
      time: new Date(newMessage.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
      type: newMessage.type || 'text',
      senderType: newMessage.senderId === user?.userId ? 'me' : 'other',
      color: newMessage.senderId === user?.userId ? 'green' : 'blue',
    };
    
    setMessages(prevMessages => [...prevMessages, formattedMessage]);
  };
  
  // Handle sending a new message
  const handleSendMessage = () => {
    if (!messageInput.trim() || !room || isSending) return;
    
    const roomId = room._id || room.id;
    setIsSending(true);
    
    try {
      // Create message payload
      const messagePayload = {
        content: messageInput.trim(),
        roomId,
        senderName: user?.fullName || user?.email || 'Unknown User',
        type: 'text' as const
      };
      
      console.log('ðŸ“¤ Sending message:', messagePayload);
      
      // Send via WebSocket
      webSocket.sendChatMessage(messagePayload);
      
      // Clear input field
      setMessageInput('');
    } catch (err: any) {
      console.error('Error sending message:', err);
      // Display error toast/notification
    } finally {
      setIsSending(false);
    }
  };
  
  // Load older messages with pagination
  const loadMoreMessages = async () => {
    if (!room || !oldestMessageId || !hasMore || isLoadingMore) return;
    
    // We'll implement this using the REST API for now since the WebSocket method 
    // would need more complex state management for callbacks
    setIsLoadingMore(true);
    
    try {
      const token = getAccessToken();
      if (!token) throw new Error("Authentication required");
      
      const roomId = room._id || room.id;
      
      // Store scroll position
      const scrollContainer = messagesContainerRef.current;
      const scrollHeight = scrollContainer?.scrollHeight;
      
      // API call with cursor parameter (implementation may vary)
      const response = await fetch(
        `${process.env.NEXT_PUBLIC_API_URL}/chat/rooms/${roomId}/messages?cursor=${oldestMessageId}&limit=20&direction=before`,
        {
          headers: {
            Authorization: `Bearer ${token}`,
          },
        }
      );
      
      const data = await response.json();
      
      if (data && Array.isArray(data.messages) && data.messages.length > 0) {
        const formattedMessages = data.messages.map((msg: any) => ({
          _id: msg._id || msg.id,
          sender: msg.senderName || 'Unknown',
          senderId: msg.senderId,
          text: msg.content,
          time: new Date(msg.createdAt).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
          type: msg.type || 'text',
          senderType: msg.senderId === user?.userId ? 'me' : 'other',
          color: msg.senderId === user?.userId ? 'green' : 'blue',
        }));
        
        // Update oldest message ID for next pagination
        if (formattedMessages.length > 0) {
          setOldestMessageId(formattedMessages[0]._id);
        }
        
        // Prepend older messages
        setMessages(prevMessages => [...formattedMessages, ...prevMessages]);
        
        // Check if there are more messages to load
        setHasMore(data.hasMore || false);
        
        // Restore scroll position
        if (scrollContainer && scrollHeight) {
          setTimeout(() => {
            scrollContainer.scrollTop = scrollContainer.scrollHeight - scrollHeight;
          }, 0);
        }
      } else {
        setHasMore(false);
      }
    } catch (err: any) {
      console.error('Error loading more messages:', err);
    } finally {
      setIsLoadingMore(false);
    }
  };
  
  // Handle scroll to load more messages
  const handleScroll = () => {
    const scrollContainer = messagesContainerRef.current;
    if (scrollContainer && scrollContainer.scrollTop === 0 && hasMore && !isLoadingMore) {
      loadMoreMessages();
    }
  };
  
  // Get the other participant's name and avatar
  const getOtherParticipant = () => {
    // For private chat, find the other user in the participants
    if (room?.participants && Array.isArray(room.participants)) {
      const otherUser = room.participants.find(
        (p: any) => p.userId !== user?.userId || p.id !== user?.userId
      );
      
      if (otherUser) {
        return {
          name: otherUser.name || 'Private Chat',
          avatar: otherUser.avatar || '/icons/direct-message.svg',
          status: room.status || ''
        };
      }
    }
    
    return {
      name: room?.name || 'Private Chat',
      avatar: '/icons/direct-message.svg',
      status: ''
    };
  };
  
  const otherParticipant = getOtherParticipant();
  
  return (
    <div className="w-2/3 flex flex-col">
      <div className="flex items-center rounded-tr-lg p-4 border-b bg-white">
        <ChatHeader
          avatar={otherParticipant.avatar}
          name={otherParticipant.name}
          status={otherParticipant.status}
        />
        {/* Additional action icons can be added here if needed */}
      </div>
      <div 
        className="flex-1 overflow-y-auto scrollbar-hide p-4"
        ref={messagesContainerRef}
        onScroll={handleScroll}
      >
        {/* Loading indicator for more messages */}
        {isLoadingMore && (
          <div className="flex justify-center py-2">
            <Loader2 className="h-5 w-5 animate-spin text-blue-600" />
          </div>
        )}
        
        {/* Date divider */}
        <div className="text-center px-4 py-2 bg-white rounded-md w-fit mx-auto text-xs text-[#030E18] my-4">
          Today
        </div>
        
        {/* Main loading state */}
        {isLoading ? (
          <div className="flex flex-col items-center justify-center h-48">
            <Loader2 className="h-8 w-8 animate-spin text-blue-600 mb-2" />
            <p className="text-sm text-gray-500">Loading messages...</p>
          </div>
        ) : error ? (
          <div className="flex flex-col items-center justify-center h-48">
            <p className="text-sm text-red-500 mb-2">{error}</p>
            <button 
              className="px-4 py-2 bg-blue-600 text-white rounded-md text-sm"
              onClick={() => window.location.reload()}
            >
              Retry
            </button>
          </div>
        ) : messages.length === 0 ? (
          <div className="flex flex-col items-center justify-center h-48">
            <p className="text-sm text-gray-500 mb-2">No messages yet</p>
            <p className="text-xs text-gray-400">Send a message to start the conversation</p>
          </div>
        ) : (
          messages.map((msg, index) => (
            <MessageBubble
              key={msg._id || index}
              msg={{
                sender: msg.sender,
                text: msg.text || msg.content || '',
                time: msg.time || '',
                type: msg.type,
                senderType: msg.senderType,
                avatar: msg.avatar || '/icons/user-placeholder.svg',
                color: msg.color || 'blue',
              }}
              index={index}
              openSubMenu={openSubMenu}
              toggleSubMenu={toggleSubMenu}
              setReplyingMessage={setReplyingMessage}
            />
          ))
        )}
        
        {/* Invisible element to scroll to */}
        <div ref={messagesEndRef} />
      </div>
      
      {replyingMessage && (
        <ReplyPreview
          replyingMessage={replyingMessage}
          onCancel={() => setReplyingMessage(null)}
        />
      )}
      
      <MessageInput 
        value={messageInput}
        onChange={(e: React.ChangeEvent<HTMLInputElement>) => setMessageInput(e.target.value)}
        onSend={handleSendMessage}
        disabled={!room || isSending || !webSocket.isConnected}
        placeholder={
          !webSocket.isConnected 
            ? "Connecting..." 
            : !room 
              ? "Select a chat to start messaging" 
              : "Type a message..."
        }
      />
    </div>
  );
}
